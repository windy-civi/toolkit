name: "Legislation Tools Pipeline"
description: "Clones repositories and runs the legislation tools pipeline on cloned data"
author: "Your Name"

inputs:
  repos:
    description: "List of repositories to clone (space-separated repository names)"
    required: true
  token:
    description: "GitHub token for authentication"
    required: false
  output_dir:
    description: "Output directory for cloned repositories"
    required: false
    default: "./govbot/repos"
  sort:
    description: "Sort order for results (ASC or DESC)"
    required: false
    default: "DESC"
  limit:
    description: "Limit the number of results (positive integer)"
    required: false
  output_file:
    description: "Path to the output file"
    required: false
    default: "./govbot/logs/govbot.log"

outputs:
  directories:
    description: "Comma-separated list of cloned directory paths"
    value: ${{ steps.pipeline.outputs.directories }}
  repository-count:
    description: "Number of repositories cloned"
    value: ${{ steps.pipeline.outputs.repository-count }}

runs:
  using: "composite"
  steps:
    - name: Setup Rust
      uses: actions-rs/toolchain@v1
      with:
        toolchain: stable
        override: true
    
    - name: Build Rust binary
      shell: bash
      working-directory: ${{ github.action_path }}
      run: |
        cargo build --release --bin govbot
    
    - name: Run pipeline
      id: pipeline
      shell: bash
      working-directory: ${{ github.action_path }}
      env:
        TOKEN: ${{ inputs.token }}
        GITHUB_OUTPUT: ${{ github.output }}
      run: |
        BINARY="target/release/govbot"
        
        # Build command with flags
        CMD="$BINARY"
        
        # Add --git-dir flag (maps from output_dir input)
        CMD="$CMD --git-dir=${{ inputs.output_dir }}"
        
        # Add --sort flag (has default in action.yml)
        CMD="$CMD --sort=${{ inputs.sort }}"
        
        # Add --limit flag only if provided (no default)
        if [ -n "${{ inputs.limit }}" ]; then
          CMD="$CMD --limit=${{ inputs.limit }}"
        fi
        
        # Add --join flag (default to minimal_metadata to match original behavior)
        CMD="$CMD --join=minimal_metadata"
        
        # Add repos as --repos flag (clap accepts multiple values)
        if [ -n "${{ inputs.repos }}" ]; then
          CMD="$CMD --repos ${{ inputs.repos }}"
        fi
        
        # Execute the command and redirect stdout to output file
        # The Rust binary writes JSON to stdout, errors to stderr
        # Errors will be visible in GitHub Actions logs, output goes to file
        $CMD > "${{ inputs.output_file }}"
